options
{
  JDK_VERSION = "1.6";
  JAVA_UNICODE_ESCAPE = true;
  STATIC = true;
}

PARSER_BEGIN(BoaParser)
package boa.parser;

public class BoaParser
{
	public void setTabSize(final int size) {
		jj_input_stream.setTabSize(size);
	}
}

PARSER_END(BoaParser)

SKIP : /* WHITE SPACE */
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

SPECIAL_TOKEN : /* COMMENTS */
{
  < SINGLE_LINE_COMMENT :
    "#" (~[ "\n", "\r" ])*
    (
      "\n"
    | "\r"
    | "\r\n"
    ) >
}

TOKEN :
{
  < DOLLAR : "$" >
| < OF : "of" >
| < IF : "if" >
| < DO : "do" >
| < OR : "or" >
| < AND : "and" >
| < ALL : "all" >
| < MAP : "map" >
| < STACK : "stack" >
| < FOR : "for" >
| < WHENEACH : "foreach" >
| < WHENALL : "ifall" >
| < WHENSOME : "exists" >
| < NOT : "not" >
| < TYPE : "type" >
| < PROC : "proc" >
| < FILE : "file" >
| < ELSE : "else" >
| < CASE : "case" >
| < SOME : "some" >
| < EACH : "each" >
| < WHEN : "when" >
| < SKIP_ : "skip" >
| < REST : "rest" >
| < OUTPUT : "output" >
| < WHILE : "while" >
| < BREAK : "break" >
| < ARRAY : "array" >
| < STATIC : "static" >
| < SWITCH : "switch" >
| < RETURN : "return" >
| < WEIGHT : "weight" >
| < RESULT : "result" >
| < DEFAULT_ : "default" >
| < CONTINUE : "continue" >
| < SUBMATCH : "submatch" >
| < FUNCTION : "function" >
| < VISITOR : "visitor" >
| < BEFORE : "before" >
| < AFTER : "after" >
| < WILDCARD : "_" >
| < STOP : "stop" >
| < PARSEDMESSAGE : "parsedmessage" >
}

TOKEN : /* LITERALS */
{
  < INTEGER_LITERAL :
    ("-")?
    (
      < BINARY_LITERAL >
    | < OCTAL_LITERAL >
    | < DECIMAL_LITERAL >
    | < HEX_LITERAL >
	)
  >
| < #BINARY_LITERAL : "0" [ "b", "B" ] ([ "0"-"1" ])+ >
| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >
| < #DECIMAL_LITERAL : [ "1"-"9" ] (< DIGIT >)* >
| < #HEX_LITERAL : "0" [ "x", "X" ] (< HEX_DIGIT_LITERAL >)+ >
| < #HEX_DIGIT_LITERAL : ( < DIGIT > | [ "a"-"f", "A"-"F" ] ) >
| < FLOATING_POINT_LITERAL :
    ("-")? 
    (
      "." (< DIGIT >)+ (< EXPONENT >)?
    | (< DIGIT >)+ < EXPONENT >
    | (< DIGIT >)+ "." (< DIGIT >)* (< EXPONENT >)?
    )
  >
| < #EXPONENT : [ "e", "E" ] ([ "+", "-" ])? (< DIGIT >)+ >
| < CHARACTER_LITERAL :
    "'"
    (
      (~[ "'", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )
    "'" >
| < REGEX_LITERAL : "`" (~[ "`", "\n", "\r" ])* "`" >
| < STRING_LITERAL :
    "\""
    (
      (~[ "\"", "\\", "\n", "\r" ])
    |
      (
        "\\"
        (
          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]
        | [ "0"-"7" ] ([ "0"-"7" ])?
        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]
        )
      )
    )*
    "\"" >
| < FINGERPRINT_LITERAL : < INTEGER_LITERAL > [ "p", "P" ] >
| < TIME_LITERAL :
    < INTEGER_LITERAL > [ "t", "T" ]
  | "T" < STRING_LITERAL > >
}

// Cribbed from the Java 1.1 grammar
TOKEN : /* IDENTIFIERS */
{
  < IDENTIFIER :
    < LETTER >
    (
      < LETTER >
    | < DIGIT >
	| "_"
    )* >
| < #LETTER : [ "a"-"z", "A"-"Z" ] >
| < #DIGIT : [ "0"-"9" ] >
}

void Start() :
{}
{
  Program() < EOF >
}

// Program = { Declaration | Statement }.
void Program() :
{}
{
  (
    LOOKAHEAD(Declaration())
    Declaration()
  | Statement()
  )+
}

// Declaration = TypeDecl | StaticVarDecl | VarDecl.
void Declaration() :
{}
{
  TypeDecl()
| StaticVarDecl()
| VarDecl()
}

// TypeDecl = 'type' type_name '=' Type ';'.
// type_name = identifier.
void TypeDecl() :
{}
{
  "type" Identifier() "=" Type() ";"
}

// StaticVarDecl = 'static' VarDecl.
void StaticVarDecl() :
{}
{
  "static" VarDecl()
}

// VarDecl = var_name ':' [Type] ['=' Expression | Block] ';'.
// var_name = identifier.
void VarDecl() :
{}
{
  Identifier() ":"
  [
    LOOKAHEAD(Type())
    Type()
  ]
  [ "=" Expression() | Block() ] ";"
}

// Type =
//   type_name | ArrayType | MapType | TupleType |
//   OutputType | FunctionType | VisitorType | StackType.
// type_name = identifier.
void Type() :
{}
{
  Identifier()
| ArrayType()
| MapType()
| TupleType()
| OutputType()
| FunctionType()
| VisitorType()
| StackType()
}

// Component = [component_name ':'] ComponentType.
// component_name = identifier.
// ComponentType = Type.
void Component() :
{}
{
  [
    LOOKAHEAD(Identifier() ":")
    Identifier() ":"
  ]
  Type()
}

// ArrayType = 'array' 'of' Element.
// Element = Component.
void ArrayType() :
{}
{
  "array" "of" Component()
}

// TupleType = '{' [MemberList] '}'.
void TupleType() :
{}
{
	"{" [ MemberList() ] "}"
}

// MemberList = Member {',' Member} [','].
void MemberList() :
{}
{
  Member()
  (
    LOOKAHEAD("," Member())
    "," Member()
  )*
  [","]
}

// Member = TypeDecl | StaticVarDecl | Component.
void Member() :
{}
{
  TypeDecl()
| StaticVarDecl()
| Component()
}

// MapType = 'map' '[' Key ']' 'of' Value.
// Key = Component.
// Value = Component.
void MapType() :
{}
{
  "map" "[" Component() "]" "of" Component()
}

// StackType = 'stack' 'of' Value.
// Value = Component.
void StackType() :
{}
{
  "stack" "of" Component()
}

// OutputType =
//   'table' table_type [Parameter] {Index} 'of' Element [Weight]
//   [FileSpec | ProcSpec ] [FormatSpec].
// table_type = identifier.
// Parameter = '(' Expression ')'.
// Index = '[' Component ']'.
// Element = Component.
// Weight = 'weight' Component.
// FileSpec = 'file' '(' ArgumentList ')'.
// ProcSpec = 'proc' '(' ArgumentList ')'.
// FormatSpec = 'format' '(' ArgumentList ')'.
// ArgumentList = ExprList.
void OutputType() :
{}
{
  "output" Identifier() [ "(" ExprList() ")" ]
  (
    "[" Component() "]"
  )*
  "of" Component()
  [
    LOOKAHEAD("weight" Component())
    "weight" Component()
  ]
  [
    "file" "(" ExprList() ")" 
  | "proc" "(" ExprList() ")"
  ]
  [ 
    LOOKAHEAD("format" "(" ExprList() ")")
    "format" "(" ExprList() ")"
  ]
}

// ExprList = Expression {',' Expression }.
void ExprList() :
{}
{
  Expression()
  (
    "," Expression()
  )*
}

// FunctionType = 'function' '(' [ParameterList] ')' [ResultSpec].
// ParameterList = Parameter {',' Parameter}.
// Parameter = identifier ':' Type.
// ResultSpec = ':' Type.
void FunctionType() :
{}
{
  "function" "(" [
    Identifier() ":" Type()
    (
      "," Identifier() ":" Type()
    )*
  ] ")"
  [ ":" Type() ]
}

// VisitorType = 'visitor'.
void VisitorType() :
{}
{
  "visitor"
}

// Statement =
//   Assignment | Block | BreakStatement | ContinueStatement | DoStatement |
//   EmitStatement | ExprStatement | ForStatement | IfStatement | ResultStatement |
//   ReturnStatement | SwitchStatement | WhenStatement | WhileStatement.
void Statement() :
{}
{
  LOOKAHEAD(Assignment())
  Assignment()
| LOOKAHEAD(Block())
  Block()
| BreakStatement()
| ContinueStatement()
| DoStatement()
| LOOKAHEAD(EmitStatement())
  EmitStatement()
| ExprStatement()
| ForStatement()
| IfStatement()
| ResultStatement()
| ReturnStatement()
| SwitchStatement()
| WhenStatement()
| WhileStatement()
| VisitStatement()
| StopStatement()
| EmptyStatement()
}

// EmptyStatement = ';'.
void EmptyStatement() :
{}
{
  ";"
}

// Assignment = Factor '=' Expression ';'.
void Assignment() :
{}
{
  Factor() "=" Expression() ";"
}

// Block = '{' { Declaration | Statement } '}'.
void Block() :
{}
{
  "{"
  (
    LOOKAHEAD(Declaration())
    Declaration()
  | Statement()
  )*
  "}"
}

// BreakStatement = 'break'.
void BreakStatement() :
{}
{
  "break" ";"
}

// ContinueStatement = 'continue'.
void ContinueStatement() :
{}
{
  "continue" ";"
}

// DoStatement = 'do' Statement 'while' '(' Expression ')' ';'.
void DoStatement() :
{}
{
  "do" Statement() "while" "(" Expression() ")" ";"
}

// EmitStatement = OutputDesignator '<<' Expression ['weight' Expression] ';'.
// OutputDesignator = var_name {'[' Expression ']'}.
void EmitStatement() :
{}
{
  Identifier() (
    "[" Expression() "]"
  )* "<<" Expression() [ "weight" Expression() ] ";"
}

// ExprStatement = Expression [ '++' | '--' ] ';'.
void ExprStatement() :
{}
{
  Expression() [ "++" | "--" ] ";"
}

// ForStatement =
//   'for' '(' [ForDeclExpr] ';' [Expression] ';' [ForDeclExpr] ')' Statement.
// ForDeclExpr = Declaration | ExprStatement.
void ForStatement() :
{}
{
  "for" "(" 
  [
    LOOKAHEAD(ForVarDecl())
    ForVarDecl()
  | ForExprStatement()
  ]
  ";"
  [ Expression() ] 
  ";"
  [
    LOOKAHEAD(ForVarDecl())
    ForVarDecl()
  | ForExprStatement()
  ]
  ")"
  Statement()
}

// needed for the lack of semicolons
void ForVarDecl() :
{}
{
  Identifier() ":"
  [
    LOOKAHEAD(Type())
    Type()
  ]
  [ "=" Expression() | Block() ]
}

// needed for the lack of semicolons
void ForExprStatement() :
{}
{
  Expression() [ "++" | "--" ]
}

// IfStatement = 'if' '(' Expression ')' Statement ['else' Statement].
void IfStatement() :
/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */
{}
{
  "if" "(" Expression() ")" Statement()
  [
    LOOKAHEAD(1)
    "else" Statement()
  ]
}

// ResultStatement = 'result' Expression.
void ResultStatement() :
{}
{
  "result" Expression() ";"
}

// ReturnStatement = 'return' [ Expression ].
void ReturnStatement() :
{}
{
  "return" [ Expression() ] ";"
}

// SwitchStatement = 'switch' '(' Expression ')' '{' { Case } Default '}'.
// Case = 'case' CaseLabelList ':' StatementList.
// CaseLabelList = Expression {',' Expression}.
// StatementList = Statement { Statement }.
// Default = 'default' ':' StatementList.
void SwitchStatement() :
{}
{
  "switch" "(" Expression() ")" "{"
  (
    "case" Expression()
    (
      "," Expression()
    )*
    ":" Statement()
    (
      Statement()
    )*
  )*
  "default" ":" Statement()
  (
    Statement()
  )* "}"
}

// WhenStatement = WhenKind '(' Parameter ';' Expression ')' Statement.
// Parameter = identifier ':' Type.
void WhenStatement() :
{}
{
  WhenKind()
  "(" Identifier() ":" Type() ";" Expression() ")"
  Statement()
}

// WhenKind = ('foreach' | 'ifall' | 'exists').
void WhenKind() :
{}
{
  < WHENEACH >
| < WHENALL >
| < WHENSOME >
}

// WhileStatement = 'while' '(' Expression ')' Statement.
void WhileStatement() :
{}
{
  "while" "(" Expression() ")" Statement()
}

void IdentifierList() :
{}
{
  Identifier()
  (
    "," Identifier()
  )*
}

// VisitStatement = ('before' | 'after') (var_name ":" type_name | IdentifierList) '->' Statement.
void VisitStatement() :
{}
{
  (
    "before" 
  | "after" 
  )
  (
    LOOKAHEAD(Identifier() ":")
    Identifier() ":" Identifier()
  | IdentifierList()
  | "_"
  )
  "->" Statement()
}

// StopStatement = ';'.
void StopStatement() :
{}
{
  "stop" ";"
}

// Expression = Conjunction {('||' | 'or') Conjunction}.
void Expression() :
{}
{
  Conjunction()
  (
    LOOKAHEAD(( "||" | "or" ) Conjunction())
    (
      "||"
    | "or"
    )
    Conjunction()
  )*
}

// Conjunction = Comparison {('&&' | 'and') Comparison}.
void Conjunction() :
{}
{
  Comparison()
  (
    (
      "&&"
    | "and"
    )
    Comparison()
  )*
}

// Comparison = SimpleExpr [relation SimpleExpr].
// relation = '==' | '!=' | '<' | '<=' | '>' | '>='.
void Comparison() :
{}
{
  SimpleExpr()
  [
    (
      "=="
    | "!="
    | "<"
    | "<="
    | ">"
    | ">="
    )
    SimpleExpr()
  ]
}

// SimpleExpr = Term {add_operator Term}.
// add_operator = '+' | '-' | '|' | '^'.
void SimpleExpr() :
{}
{
  Term()
  (
    (
      "+"
    | "-"
    | "|"
    | "^"
    )
    Term()
  )*
}

// Term = Factor {mul_operator Factor}.
// mul_operator = '*' | '/' | '%' | '<<' | '>>' | '&'.
void Term() :
{}
{
  Factor()
  (
    (
      "*"
    | "/"
    | "%"
    | "<<"
    | ">>"
    | "&"
    )
    Factor()
  )*
}

// Factor = Operand { Selector | Index | Call }.
void Factor() :
{}
{
  Operand()
  (
    Selector()
  | Index()
  | Call()
  )*
}

// Selector = '.' field_name.
// field_name = identifier.
void Selector() :
{}
{
  "." Identifier()
}

// Index = '[' Expression [':' Expression] ']'.
void Index() :
{}
{
  "[" Expression() [ ":" Expression() ] "]"
}

// Call = '(' ArgumentList ')'.
void Call() :
{}
{
  "(" [ ExprList() ] ")"
}

// Operand =
//   identifier | literal | Composite | Function | unary_operator Factor |
//   '$' | StatementExpr | '(' Expression ')'.
// unary_operator = '+' | '-' | '~' | '!' | 'not'.
void Operand() :
{}
{
  LOOKAHEAD(Identifier())
  Identifier()
| StringLiteral()
| CharLiteral()
| TimeLiteral()
| IntegerLiteral()
| FloatingPointLiteral()
| LOOKAHEAD(Composite())
  Composite()
| VisitorExpr()
| Function()
| (
    "+"
  | "-"
  | "~"
  | "!"
  | "not"
  )
  Factor()
| "$"
| StatementExpr()
| "(" Expression() ")"
}

// Composite = '{' [ExprList | PairList | ':'] '}'.
void Composite() :
{}
{
 "{"
    [
      LOOKAHEAD(Pair())
      PairList()
    | ExprList()
    | ":"
    ]
 "}"
}

// PairList = Pair {',' Pair}.
void PairList() :
{}
{
  Pair()
  (
    "," Pair()
  )*
}

// Pair = Expression ':' Expression.
void Pair() :
{}
{
  Expression() ":" Expression()
}

// Function = FunctionType Block.
void Function() :
{}
{
  FunctionType() Block()
}

// VisitorExpr = VisitorType Block.
void VisitorExpr() :
{}
{
  VisitorType() Block()
}

// StatementExpr = '?' Block .
void StatementExpr() :
{}
{
  "?" Block()
}

// identifier = letter {letter | '_' | digit}.
// letter = 'A' .. 'Z' | 'a' .. 'z'.
// digit = '0' .. '9'.
void Identifier() :
{}
{
  < IDENTIFIER >
}

// integer = ['-'] (binary_int | octal_int | decimal_int | hexadecimal_int).

// binary_int = '0' ('B' | 'b') bin_digit {bin_digit}.
// octal_int = '0' oct_digit {oct_digit}.
// decimal_int = dec_digit {dec_digit}.
// hexadecimal_int = '0' ('X' | 'x') hex_digit {hex_digit}.

// bin_digit = '0' .. '1'.
// oct_digit = '0' .. '7'.
// dec_digit = '0' .. '9'.
// hex_digit = '0' .. '9' | 'A' .. 'F' | 'a' .. 'f'.
void IntegerLiteral() :
{}
{
  < INTEGER_LITERAL >
}


// fingerprint = integer ('P' | 'p').
void FingerprintLiteral() :
{}
{
  < FINGERPRINT_LITERAL >
}


// floating_point = ['-'] [integer_part]['.' [fraction_part]] [scale_factor].
// 
// integer_part = decimal_int.
// fraction_part = decimal_int.
// scale_factor = ('E' | 'e') ['+'|'-'] exponent.
// exponent = decimal_int.
void FloatingPointLiteral() :
{}
{
  < FLOATING_POINT_LITERAL >
}

// char = ''' character '''.
// character = ordinary_character | escaped_character.
// escaped_character =
//   '\' oct_digit [oct_digit [oct_digit]] |
//   '\' 'x' hex_digit {hex_digit} |
//   '\' 'u' hex_digit hex_digit hex_digit hex_digit |
//   '\' 'U' hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit |
//   '\' ('a' | 'b' | 'f' | 'n' | 'r' | 't' | 'v' | '\' | '"') |
//   '\' ordinary_character.
void CharLiteral() :
{}
{
  < CHARACTER_LITERAL >
}

// string = '"' {character} '"' | '`' {character} '`'.
void StringLiteral() :
{}
{
  < STRING_LITERAL >
  | < REGEX_LITERAL >
}

// time = integer ('T' | 't') | 'T' string.
void TimeLiteral() :
{}
{
  < TIME_LITERAL >
}
