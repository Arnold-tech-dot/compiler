p: Project = input;
finalentropy: output collection[string][string][int][int][int][int] of float;
type T = enum {fix = "Buggy", notfix = "NotBuggy"};
type T1 = {a: ChangedFile, b: string , c: string, d: int, e:int};
files: map[string] of T1;
str : string;
cname: string;

collect : output collection[string][string][int][int][int][int] of string;

# loc, number_of_dev, number_of_times_file_changed, methodcall, fix
train : output randomforest of {int,int,int,int, T};

visit(p, visitor {
    after node: CodeRepository -> {
	ndev : int;
	count: int;
	mcall : int;
	arr := keys(files);
	vals := values(files);
	l := len(arr);

    	while(l != 0) {
		ndev = len(splitall(vals[l-1].c, ","));
		count = 0;
		mcall = 0;

		visit(getast(vals[l-1].a), visitor {
        		before node: Statement ->
            				count = count + 1;
			
			before node: Expression ->
				if (node.kind == ExpressionKind.METHODCALL)
					mcall++;
    		});

		if(vals[l-1].b == "Buggy")
			train << {count, ndev, vals[l-1].d, mcall, T.fix }; 
		else
			train << {count,ndev,vals[l-1].d, mcall, T.notfix}; 

		#collect[p.project_url][arr[l-1]][count][ndev][vals[l-1].d][mcall] << vals[l-1].b;

		l--;	
	}
    }

    before node: Revision -> {
	filename: string;
	cname = node.committer.username;

	if(isfixingrevision(node.log)) {
		foreach (i: int; def(node.files[i])) {

			filename =  node.files[i].name;

			if(!haskey(files, filename))
	            		files[filename] = {node.files[i], "Buggy", cname, 1, 1};
			else
				if(strfind(cname, files[filename].c) == -1)
					files[filename] = {node.files[i], "Buggy" , files[filename].c + "," + cname, files[filename].d + 1, files[filename].e + 1}; 
				else 
					files[filename] = {node.files[i], "Buggy", cname, files[filename].d + 1, files[filename].e + 1};
		}
	
	}
	else {
		foreach (i: int; def(node.files[i])) {
			filename =  node.files[i].name;
			if(!haskey(files, filename))
	            		files[filename] = {node.files[i], "NotBuggy", cname, 1, 0};
			else
				if(strfind(cname, files[filename].c) == -1)
					files[filename] = {node.files[i], files[filename].b, files[filename].c + "," + cname, files[filename].d + 1, files[filename].e}; 
				else 
					files[filename] =  {node.files[i], files[filename].b, files[filename].c, files[filename].d + 1, files[filename].e};
						
		
		}
	}

}
	
});
